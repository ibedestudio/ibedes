---
export interface Props {
  slug: string;
  title: string;
}

const { slug, title } = Astro.props;

const safeSlug = slug?.trim?.().replace(/^\/+|\/+$/g, "") || "artikel";
const seedLikes = 0;

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL ?? "";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY ?? "";
const supabaseEnabled = Boolean(supabaseUrl && supabaseAnonKey);
---

<section
  class="rounded-3xl border-2 border-black/70 dark:border-white/60 bg-white/80 dark:bg-zinc-900/70 p-6 flex flex-col gap-8"
  data-engagement
  data-slug={safeSlug}
  data-title={title}
  data-likes-seed={seedLikes}
  data-supabase-ready={supabaseEnabled ? "true" : "false"}
  data-supabase-url={supabaseEnabled ? supabaseUrl : undefined}
  data-supabase-key={supabaseEnabled ? supabaseAnonKey : undefined}
>
  <div class="engagement-fab" data-floating-controls hidden>
    <button
      type="button"
      class="engagement-fab__button engagement-fab__button-like"
      data-like-button
      aria-label="Kirim tepuk"
    >
      <i class="fa-solid fa-heart text-red-500 text-xl"></i>
      <span class="engagement-fab__count" data-like-count>0</span>
      <span class="floating-heart-container" data-floating-heart-container
      ></span>
    </button>
    <button
      type="button"
      class="engagement-fab__button"
      data-scroll-comments
      aria-label="Buka komentar"
    >
      <i class="fa-solid fa-comment text-xl"></i>
    </button>
  </div>

  <div class="engagement-mobile-bar" data-floating-controls hidden>
    <button
      type="button"
      class="engagement-mobile-bar__action"
      data-like-button
      aria-label="Kirim tepuk"
    >
      <i class="fa-solid fa-heart text-red-500 text-lg"></i>
      <span class="font-semibold" data-like-count>0</span>
      <span class="text-xs uppercase tracking-[0.3em]">Tepuk</span>
      <span class="floating-heart-container" data-floating-heart-container
      ></span>
    </button>
    <button
      type="button"
      class="engagement-mobile-bar__action"
      data-scroll-comments
      aria-label="Menuju komentar"
    >
      <i class="fa-solid fa-comment text-lg"></i>
      <span class="font-mono text-xs uppercase tracking-[0.3em]">Komentar</span>
    </button>
  </div>

  <!-- Comment popup modal -->
  <div class="comment-popup-overlay" data-comment-popup hidden>
    <div class="comment-popup-modal">
      <div class="comment-popup-header">
        <h3 class="font-display text-lg uppercase tracking-[0.2em]">
          Komentar
        </h3>
        <button
          type="button"
          class="comment-popup-close"
          data-comment-close
          aria-label="Tutup komentar"
        >
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="comment-popup-content">
        <p class="text-sm text-zag-dark/80 dark:text-zag-light/80 mb-4">
          Ceritakan satu hal yang kamu rasakan setelah membaca artikel ini.
        </p>
        <p
          class="text-xs text-zag-dark/70 dark:text-zag-light/60"
          data-loading-state
        >
          Menyiapkan data interaksi...
        </p>
        <p
          class="text-sm font-mono uppercase tracking-[0.3em] text-emerald-700 dark:text-emerald-300 hidden"
          data-status-message
          aria-live="polite"
        >
        </p>
        <ul
          class="flex flex-col gap-4 max-h-64 overflow-y-auto"
          data-comment-list
        >
        </ul>
        <p
          class="text-sm text-zag-dark/70 dark:text-zag-light/70 italic"
          data-empty-comments
        >
          Belum ada komentar. Mulai duluan, yuk?
        </p>
        <form class="flex flex-col gap-4 mt-4" data-comment-form>
          <label class="flex flex-col gap-1 text-sm">
            <span>Nama (opsional)</span>
            <input
              type="text"
              name="name"
              class="rounded-2xl border-2 border-black/40 dark:border-white/40 bg-transparent px-4 py-2 outline-none focus-visible:border-emerald-400"
              placeholder="Mis. Nadya, Teman Belajar"
              autocomplete="name"
            />
          </label>
          <label class="flex flex-col gap-1 text-sm">
            <span>Pesan</span>
            <textarea
              name="comment"
              class="rounded-2xl border-2 border-black/40 dark:border-white/40 bg-transparent px-4 py-2 outline-none focus-visible:border-emerald-400 min-h-[100px]"
              placeholder="Apa bagian favoritmu, atau apa yang ingin kamu coba setelah ini?"
              required></textarea>
          </label>
          <button
            type="submit"
            class="self-start rounded-2xl border-2 border-black/70 dark:border-white/70 px-4 py-3 font-mono text-xs uppercase tracking-[0.3em] zag-transition hover:-translate-y-0.5 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-400 disabled:opacity-60"
          >
            Kirim Komentar
          </button>
        </form>
      </div>
    </div>
  </div>

  <script is:inline>
    (() => {
      if (typeof window === "undefined") return;

      const script = document.currentScript;
      const root = script?.closest?.("[data-engagement]");
      if (!root) return;

      const slug = root.getAttribute("data-slug") ?? "artikel";
      const likesSeed = Number(root.getAttribute("data-likes-seed")) || 0;
      const supabaseReady = root.getAttribute("data-supabase-ready") === "true";
      const supabaseUrl =
        root.getAttribute("data-supabase-url")?.replace(/\/+$/, "") ?? "";
      const supabaseKey = root.getAttribute("data-supabase-key") ?? "";
      const likeButtons = Array.from(
        root.querySelectorAll("[data-like-button]"),
      );
      const primaryLikeButton = likeButtons[0] ?? null;
      const likeCountEls = Array.from(
        root.querySelectorAll("[data-like-count]"),
      );
      const likeAnimator = root.querySelector("[data-like-animator]");
      const floatingHeartContainers = Array.from(
        root.querySelectorAll("[data-floating-heart-container]"),
      );
      const commentList = root.querySelector("[data-comment-list]");
      const emptyState = root.querySelector("[data-empty-comments]");
      const form = root.querySelector("[data-comment-form]");
      const nameInput = form?.querySelector?.("[name='name']");
      const commentInput = form?.querySelector?.("[name='comment']");
      const submitButton = form?.querySelector?.("button[type='submit']");
      const loadingState = root.querySelector("[data-loading-state]");
      const statusMessage = root.querySelector("[data-status-message]");
      const commentButtons = Array.from(
        root.querySelectorAll("[data-scroll-comments]"),
      );
      const floatingControls = Array.from(
        root.querySelectorAll("[data-floating-controls]"),
      );

      const likesKey = `ibedes:likes:${slug}`;
      const commentsKey = `ibedes:comments:${slug}`;
      const userHashKey = `ibedes:user-hash`;
      const MAX_CLAPS = 50;
      const useRemote = supabaseReady && Boolean(supabaseUrl && supabaseKey);
      let supabaseClient = null;
      let realtimeChannel = null;
      let supabaseModulePromise = null;

      const parseJSON = (value) => {
        try {
          return JSON.parse(value ?? "");
        } catch {
          return null;
        }
      };

      const generateId = () =>
        typeof crypto !== "undefined" && crypto.randomUUID
          ? crypto.randomUUID()
          : `${Date.now()}-${Math.random().toString(16).slice(2)}`;

      const loadSupabaseClient = async () => {
        if (!useRemote) return null;
        if (supabaseClient) return supabaseClient;
        if (!supabaseModulePromise) {
          supabaseModulePromise = import(
            "https://esm.sh/@supabase/supabase-js@2.45.2",
          );
        }
        const { createClient } = await supabaseModulePromise;
        supabaseClient = createClient(supabaseUrl, supabaseKey, {
          auth: { persistSession: false },
        });
        return supabaseClient;
      };

      const normalizeLikesState = (state) => {
        if (!state || typeof state !== "object") {
          return {
            count: likesSeed,
            claps: 0,
          };
        }
        const next = {
          count: Number.isFinite(Number(state.count))
            ? Number(state.count)
            : likesSeed,
          claps: Number.isFinite(Number(state.claps))
            ? Number(state.claps)
            : state.liked
              ? 1
              : 0,
        };
        next.claps = Math.max(0, Math.min(MAX_CLAPS, next.claps));
        return next;
      };

      let likesState = normalizeLikesState(
        parseJSON(window.localStorage.getItem(likesKey)),
      );

      const setStatusMessage = (message = "", variant = "info") => {
        if (!statusMessage) return;
        if (!message) {
          statusMessage.hidden = true;
          statusMessage.textContent = "";
          statusMessage.style.color = "";
          return;
        }
        statusMessage.hidden = false;
        statusMessage.textContent = message;
        statusMessage.style.color =
          variant === "error" ? "rgb(220,38,38)" : "rgb(4,120,87)";
      };

      const setLoading = (state) => {
        if (!loadingState) return;
        loadingState.hidden = !state;
      };

      const updateLikeUI = () => {
        likeCountEls.forEach((el) => {
          el.textContent = `${likesState.count}`;
        });
        likeButtons.forEach((button) => {
          const reachedLimit = likesState.claps >= MAX_CLAPS;
          button.disabled = reachedLimit;
          button.setAttribute(
            "aria-pressed",
            likesState.claps > 0 ? "true" : "false",
          );
        });
      };

      const persistLikes = () => {
        window.localStorage.setItem(likesKey, JSON.stringify(likesState));
      };

      const getUserHash = () => {
        const existing = window.localStorage.getItem(userHashKey);
        if (existing) return existing;
        const fresh =
          window.crypto?.randomUUID?.() ??
          `${Date.now()}-${Math.random().toString(16).slice(2)}`;
        window.localStorage.setItem(userHashKey, fresh);
        return fresh;
      };

      const userHash = getUserHash();

      const spawnFloatingHeart = (container) => {
        if (!container) return;
        const heart = document.createElement("span");
        heart.className = "floating-heart";
        heart.innerHTML = '<i class="fa-solid fa-heart text-red-500"></i>';
        heart.style.setProperty(
          "--heart-spread",
          `${(Math.random() - 0.5) * 40}px`,
        );
        heart.style.setProperty(
          "--heart-scale",
          `${0.8 + Math.random() * 0.5}`,
        );
        container.appendChild(heart);
        heart.addEventListener(
          "animationend",
          () => {
            heart.remove();
          },
          { once: true },
        );
      };

      const spawnFloatingHeartsInAllContainers = () => {
        // Spawn hearts in floating containers (fab and mobile bar)
        floatingHeartContainers.forEach((container) => {
          if (container) {
            spawnFloatingHeart(container);
          }
        });

        // Also spawn in the main like animator if it exists (for embedded button)
        if (likeAnimator) {
          spawnFloatingHeart(likeAnimator);
        }
      };

      const applyClapLocally = () => {
        likesState = {
          ...likesState,
          count: likesState.count + 1,
          claps: Math.min(MAX_CLAPS, likesState.claps + 1),
        };
        persistLikes();
        updateLikeUI();
        spawnFloatingHeartsInAllContainers();
      };

      updateLikeUI();
      floatingControls.forEach((el) => {
        el.hidden = false;
        el.classList.add(
          "engagement-floating-container",
          "engagement-floating--hidden",
        );
      });

      const updateFloatingVisibility = () => {
        const doc = document.documentElement;
        const scrollTop = doc.scrollTop || document.body.scrollTop || 0;
        const scrollHeight =
          doc.scrollHeight || document.body.scrollHeight || 0;
        const clientHeight = doc.clientHeight || window.innerHeight || 1;
        const maxScroll = Math.max(1, scrollHeight - clientHeight);
        const progress =
          scrollHeight <= clientHeight ? 1 : scrollTop / maxScroll;
        const shouldShow = progress >= 0.3;
        floatingControls.forEach((el) => {
          el.classList.toggle("engagement-floating--visible", shouldShow);
          el.classList.toggle("engagement-floating--hidden", !shouldShow);
        });
      };

      updateFloatingVisibility();
      window.addEventListener("scroll", updateFloatingVisibility, {
        passive: true,
      });

      const showCommentPopup = () => {
        const popup = root.querySelector("[data-comment-popup]");
        if (popup) {
          popup.hidden = false;
          // Focus on comment input after popup is shown
          if (commentInput) {
            setTimeout(() => commentInput.focus(), 300);
          }
        }
      };

      const hideCommentPopup = () => {
        const popup = root.querySelector("[data-comment-popup]");
        if (popup) {
          popup.hidden = true;
        }
      };

      commentButtons.forEach((button) => {
        button.addEventListener("click", () => {
          showCommentPopup();
        });
      });

      // Close popup events
      const closeButton = root.querySelector("[data-comment-close]");
      const popup = root.querySelector("[data-comment-popup]");

      closeButton?.addEventListener("click", hideCommentPopup);

      popup?.addEventListener("click", (event) => {
        if (event.target === popup) {
          hideCommentPopup();
        }
      });

      // ESC key to close popup
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !popup?.hidden) {
          hideCommentPopup();
        }
      });

      const renderEmptyState = () => {
        if (!emptyState) return;
        emptyState.hidden = Boolean(comments.length);
      };

      const sanitize = (value, fallback = "") => {
        if (typeof value !== "string") return fallback;
        return value.trim() || fallback;
      };

      const normalizeRemoteComment = (comment) => {
        if (!comment) return null;
        return {
          id: sanitize(String(comment.id ?? "")) || generateId(),
          name: sanitize(comment.name, "Anonim"),
          message: sanitize(comment.message),
          createdAt: comment.created_at ?? new Date().toISOString(),
        };
      };

      const formatDate = (isoString) => {
        try {
          return new Intl.DateTimeFormat("id-ID", {
            dateStyle: "medium",
            timeStyle: "short",
          }).format(new Date(isoString));
        } catch {
          return isoString;
        }
      };

      const buildCommentItem = (comment) => {
        const li = document.createElement("li");
        li.dataset.commentId = comment.id;
        li.className =
          "flex flex-col gap-1 rounded-2xl border border-black/15 dark:border-white/20 bg-white/80 dark:bg-black/30 p-4";
        li.innerHTML = `
          <div class="flex items-center justify-between gap-4">
            <p class="font-semibold">${comment.name}</p>
            <span class="text-xs text-zag-dark/70 dark:text-zag-light/70">${formatDate(comment.createdAt)}</span>
          </div>
          <p class="text-sm leading-relaxed">${comment.message}</p>
        `;
        return li;
      };

      const loadComments = () => {
        const stored = parseJSON(window.localStorage.getItem(commentsKey));
        if (!Array.isArray(stored)) return [];
        return stored;
      };

      let comments = useRemote ? [] : loadComments();

      const renderComments = () => {
        if (!commentList) return;
        commentList.innerHTML = "";
        comments.forEach((comment) => {
          commentList.appendChild(buildCommentItem(comment));
        });
        renderEmptyState();
      };

      const persistComments = () => {
        if (useRemote) return;
        window.localStorage.setItem(
          commentsKey,
          JSON.stringify(comments.slice(0, 50)),
        );
      };

      if (!useRemote) {
        renderComments();
        setLoading(false);
      }

      const supabaseHeaders = () => ({
        apikey: supabaseKey,
        Authorization: `Bearer ${supabaseKey}`,
        "Content-Type": "application/json",
      });

      const fetchLikeCount = async () => {
        if (!useRemote) return likesState.count;
        const params = new URLSearchParams({
          select: "id",
          slug: `eq.${slug}`,
        });
        const response = await fetch(
          `${supabaseUrl}/rest/v1/article_likes?${params.toString()}`,
          {
            headers: {
              ...supabaseHeaders(),
              Prefer: "count=exact",
            },
          },
        );
        if (!response.ok) {
          throw new Error("Gagal memuat data suka");
        }
        const range = response.headers.get("content-range");
        if (range && /\/(\d+)$/.test(range)) {
          const [, total] = range.match(/\/(\d+)$/) ?? [];
          return Number(total) || likesState.count;
        }
        const data = await response.json();
        return Array.isArray(data) ? data.length : likesState.count;
      };

      const fetchCommentsRemote = async () => {
        if (!useRemote) return comments;
        const params = new URLSearchParams({
          select: "id,name,message,created_at",
          slug: `eq.${slug}`,
          order: "created_at.desc",
          limit: "50",
        });
        const response = await fetch(
          `${supabaseUrl}/rest/v1/article_comments?${params.toString()}`,
          {
            headers: supabaseHeaders(),
          },
        );
        if (!response.ok) {
          throw new Error("Gagal memuat komentar");
        }
        const data = await response.json();
        if (!Array.isArray(data)) return [];
        return data
          .map((comment) => normalizeRemoteComment(comment))
          .filter(Boolean);
      };

      const subscribeToRealtime = async () => {
        if (!useRemote || realtimeChannel) return;
        const client = await loadSupabaseClient();
        if (!client) return;

        realtimeChannel = client.channel(`article-engagement:${slug}`);

        realtimeChannel.on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "article_likes",
            filter: `slug=eq.${slug}`,
          },
          (payload) => {
            const newLike = payload.new;
            if (!newLike || newLike.user_hash === userHash) return;
            likesState = {
              ...likesState,
              count: likesState.count + 1,
            };
            updateLikeUI();
          },
        );

        realtimeChannel.on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "article_comments",
            filter: `slug=eq.${slug}`,
          },
          (payload) => {
            const incoming = normalizeRemoteComment(payload.new);
            if (!incoming) return;
            const alreadyExists = comments.some(
              (comment) => comment.id === incoming.id,
            );
            if (alreadyExists) return;
            comments = [incoming, ...comments].slice(0, 50);
            renderComments();
          },
        );

        realtimeChannel.subscribe((status) => {
          if (status === "SUBSCRIBED") {
            setStatusMessage("Terhubung realtime dengan Supabase.");
          }
        });
      };

      const bootstrap = async () => {
        if (!useRemote) return;
        try {
          setLoading(true);
          const [remoteLikes, remoteComments] = await Promise.all([
            fetchLikeCount(),
            fetchCommentsRemote(),
          ]);
          likesState.count = Number.isFinite(remoteLikes)
            ? remoteLikes
            : likesState.count;
          comments = remoteComments;
          persistLikes();
          renderComments();
          updateLikeUI();
          setStatusMessage("Data tersinkron dengan Supabase.");
          subscribeToRealtime();
        } catch (error) {
          console.error(error);
          setStatusMessage(
            "Gagal memuat data Supabase. Menampilkan cadangan lokal.",
            "error",
          );
          comments = loadComments();
          renderComments();
        } finally {
          setLoading(false);
        }
      };

      bootstrap();

      form?.addEventListener("submit", (event) => {
        event.preventDefault();
        const message = commentInput?.value?.trim();
        if (!message) {
          commentInput?.focus();
          return;
        }
        const name = nameInput?.value?.trim() || "Anonim";

        const submitLocalComment = (
          createdAt = new Date().toISOString(),
          id,
        ) => {
          const newComment = {
            id: id || generateId(),
            name,
            message,
            createdAt,
          };
          comments = [newComment, ...comments].slice(0, 50);
          persistComments();
          renderComments();
          form.reset();
        };

        const sendToSupabase = async () => {
          if (!useRemote) {
            submitLocalComment();
            setStatusMessage("Komentar tersimpan di perangkatmu.");
            return;
          }
          submitButton?.setAttribute("disabled", "true");
          setStatusMessage("Mengirim komentar...");
          try {
            const response = await fetch(
              `${supabaseUrl}/rest/v1/article_comments`,
              {
                method: "POST",
                headers: {
                  ...supabaseHeaders(),
                  Prefer: "return=representation",
                },
                body: JSON.stringify({
                  slug,
                  name,
                  message,
                  status: "published",
                }),
              },
            );
            if (!response.ok) {
              throw new Error("Komentar gagal dikirim");
            }
            const data = await response.json();
            const saved = Array.isArray(data) ? data[0] : null;
            submitLocalComment(
              saved?.created_at ?? new Date().toISOString(),
              saved?.id,
            );
            setStatusMessage("Komentar terkirim!");
          } catch (error) {
            console.error(error);
            submitLocalComment();
            setStatusMessage(
              "Gagal ke Supabase, komentar disimpan lokal.",
              "error",
            );
          } finally {
            submitButton?.removeAttribute("disabled");
          }
        };

        sendToSupabase();
      });

      const handleSupabaseLike = async () => {
        if (likesState.claps >= MAX_CLAPS) {
          setStatusMessage(
            "Kamu sudah memberi 50 tepuk untuk artikel ini.",
            "error",
          );
          return;
        }

        if (!useRemote) {
          applyClapLocally();
          setStatusMessage(
            `Tepuk tersimpan di perangkatmu (${likesState.claps}/${MAX_CLAPS}).`,
          );
          return;
        }
        primaryLikeButton?.setAttribute("data-loading", "true");
        setStatusMessage("Mengirim suka...");
        try {
          const response = await fetch(`${supabaseUrl}/rest/v1/article_likes`, {
            method: "POST",
            headers: {
              ...supabaseHeaders(),
              Prefer: "return=minimal",
            },
            body: JSON.stringify({
              slug,
              user_hash: userHash,
            }),
          });
          if (!response.ok) {
            throw new Error("Gagal menambahkan suka");
          }
          applyClapLocally();
          setStatusMessage(
            likesState.claps >= MAX_CLAPS
              ? "Terima kasih! Batas 50 tepuk sudah kamu capai."
              : "Terima kasih sudah apresiasi!",
          );
        } catch (error) {
          console.error(error);
          setStatusMessage("Suka gagal dikirim. Coba lagi.", "error");
        } finally {
          primaryLikeButton?.removeAttribute("data-loading");
        }
      };

      likeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          if (likesState.claps >= MAX_CLAPS) {
            setStatusMessage(
              "Kamu sudah memberi 50 tepuk untuk artikel ini.",
              "error",
            );
            return;
          }
          handleSupabaseLike();
        });
      });

      if (useRemote) {
        window.addEventListener("online", () => {
          bootstrap();
        });
      }
    })();
  </script>
</section>

<style>
  .engagement-floating-container {
    opacity: 0;
    transform: translateY(12px);
    transition:
      opacity 220ms ease,
      transform 260ms ease;
    pointer-events: none;
  }

  .engagement-floating--visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .engagement-floating--hidden {
    opacity: 0;
    transform: translateY(12px);
    pointer-events: none;
  }

  .engagement-fab {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    display: none;
    flex-direction: column;
    gap: 0.75rem;
    z-index: 40;
  }

  .engagement-fab__button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 3.25rem;
    height: 3.25rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.6);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
    color: #111;
    font-size: 1.3rem;
    transition:
      transform 150ms ease,
      border-color 150ms ease;
    position: relative;
  }

  .engagement-fab__button-like {
    position: relative;
  }

  .floating-heart-container {
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    pointer-events: none;
    z-index: 10;
  }

  .engagement-fab__button:hover {
    transform: translateY(-2px);
    border-color: rgba(16, 185, 129, 0.9);
  }

  .engagement-fab__count {
    font-size: 0.85rem;
    font-weight: 600;
    margin-left: 0.35rem;
  }

  .engagement-mobile-bar {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 1rem;
    width: min(92vw, 360px);
    display: none;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
    z-index: 40;
    backdrop-filter: blur(8px);
  }

  .engagement-mobile-bar__action {
    flex: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.4);
    background: transparent;
    font-size: 0.95rem;
    padding: 0.4rem 0.6rem;
    position: relative;
  }

  .engagement-mobile-bar__action:first-of-type {
    position: relative;
  }

  .engagement-mobile-bar .floating-heart-container {
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    pointer-events: none;
    z-index: 10;
  }

  .engagement-mobile-bar__action:first-of-type {
    background: rgba(16, 185, 129, 0.12);
    border-color: rgba(16, 185, 129, 0.5);
  }

  @media (max-width: 1023px) {
    .engagement-mobile-bar {
      display: flex;
    }
  }

  @media (min-width: 1024px) {
    .engagement-fab {
      display: flex;
    }
    .engagement-mobile-bar {
      display: none;
    }
  }

  :global(.dark)
    [data-engagement]
    :where(
      .engagement-fab__button,
      .engagement-mobile-bar,
      .engagement-mobile-bar__action
    ) {
    background: rgba(24, 24, 27, 0.9);
    border-color: rgba(255, 255, 255, 0.2);
    color: #f8fafc;
  }

  :global(.dark)
    [data-engagement]
    :where(
      .engagement-fab__button-like,
      .engagement-mobile-bar__action:first-of-type
    ) {
    background: rgba(16, 185, 129, 0.14);
    border-color: rgba(16, 185, 129, 0.5);
    color: #ecfdf5;
  }

  [data-like-animator] {
    pointer-events: none;
  }

  :global(.floating-heart) {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.2rem;
    animation: heartFloat 1200ms cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    opacity: 0.95;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    will-change: transform, opacity;
    z-index: 15;
  }

  @keyframes heartFloat {
    0% {
      transform: translate(-50%, -50%) translateX(var(--heart-spread, 0px))
        scale(var(--heart-scale, 0.8));
      opacity: 0.95;
    }
    30% {
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -250%)
        translateX(calc(var(--heart-spread, 0px) * 2))
        scale(calc(var(--heart-scale, 0.8) + 0.5));
      opacity: 0;
    }
  }

  /* Comment Popup Styles */
  .comment-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    z-index: 50;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    animation: popupFadeIn 0.2s ease-out;
  }

  .comment-popup-modal {
    background: white;
    border: 2px solid rgba(0, 0, 0, 0.7);
    border-radius: 1.5rem;
    max-width: 500px;
    width: 100%;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    animation: popupSlideIn 0.3s ease-out;
  }

  .comment-popup-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  }

  .comment-popup-close {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    border: 1px solid rgba(0, 0, 0, 0.3);
    background: transparent;
    color: rgba(0, 0, 0, 0.7);
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .comment-popup-close:hover {
    background: rgba(0, 0, 0, 0.1);
    transform: scale(1.05);
  }

  .comment-popup-content {
    padding: 1.5rem;
    max-height: calc(80vh - 120px);
    overflow-y: auto;
  }

  .comment-popup-content::-webkit-scrollbar {
    width: 4px;
  }

  .comment-popup-content::-webkit-scrollbar-track {
    background: transparent;
  }

  .comment-popup-content::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 2px;
  }

  @keyframes popupFadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes popupSlideIn {
    from {
      opacity: 0;
      transform: translateY(20px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  /* Mobile Responsive */
  @media (max-width: 640px) {
    .comment-popup-overlay {
      padding: 0.5rem;
      align-items: flex-end;
    }

    .comment-popup-modal {
      border-radius: 1rem 1rem 0 0;
      max-height: 85vh;
      animation: popupSlideUp 0.3s ease-out;
    }

    .comment-popup-content {
      padding: 1rem;
      max-height: calc(85vh - 100px);
    }
  }

  @keyframes popupSlideUp {
    from {
      opacity: 0;
      transform: translateY(100%);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Dark mode adjustments */
  :global(.dark) .comment-popup-modal {
    background: rgb(24, 24, 27);
    border-color: rgba(255, 255, 255, 0.6);
  }

  :global(.dark) .comment-popup-header {
    border-bottom-color: rgba(255, 255, 255, 0.2);
  }

  :global(.dark) .comment-popup-close {
    color: rgba(255, 255, 255, 0.7);
    border-color: rgba(255, 255, 255, 0.3);
  }

  :global(.dark) .comment-popup-close:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  :global(.dark) .comment-popup-content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
  }
</style>
