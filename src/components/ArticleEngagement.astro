---
export interface Props {
  slug: string;
  title: string;
}

const { slug, title } = Astro.props;

const safeSlug = slug?.trim?.().replace(/^\/+|\/+$/g, "") || "artikel";
const seedLikes = 0;

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL ?? "";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY ?? "";
const supabaseEnabled = Boolean(supabaseUrl && supabaseAnonKey);
---

<section
  class="relative block"
  data-engagement
  data-slug={safeSlug}
  data-title={title}
  data-likes-seed={seedLikes}
  data-supabase-ready={supabaseEnabled ? "true" : "false"}
  data-supabase-url={supabaseEnabled ? supabaseUrl : undefined}
  data-supabase-key={supabaseEnabled ? supabaseAnonKey : undefined}
>
  <div class="engagement-fab" data-floating-controls hidden>
    <button
      type="button"
      class="engagement-fab__button engagement-fab__button-like"
      data-like-button
      aria-label="Kirim tepuk"
    >
      <i aria-hidden="true" class="fa-solid fa-heart engagement-icon engagement-icon--love"></i>
      <span class="engagement-fab__count" data-like-count>0</span>
    </button>
    <button
      type="button"
      class="engagement-fab__button"
      data-comment-toggle
      aria-label="Buka komentar"
    >
      <i aria-hidden="true" class="fa-regular fa-comment engagement-icon engagement-icon--comment"></i>
    </button>
  </div>

  <div class="engagement-mobile-bar" data-floating-controls hidden>
    <button
      type="button"
      class="engagement-mobile-bar__action"
      data-like-button
      aria-label="Kirim tepuk"
    >
      <i aria-hidden="true" class="fa-solid fa-heart engagement-icon engagement-icon--love"></i>
      <span class="font-semibold" data-like-count>0</span>
      <span class="text-xs uppercase tracking-[0.3em]">Tepuk</span>
    </button>
    <button
      type="button"
      class="engagement-mobile-bar__action"
      data-comment-toggle
      aria-label="Menuju komentar"
    >
      <i aria-hidden="true" class="fa-regular fa-comment engagement-icon engagement-icon--comment"></i>
      <span class="font-mono text-xs uppercase tracking-[0.3em]">Komentar</span>
    </button>
  </div>
  <div
    class="comment-modal"
    data-comment-modal
    hidden
    aria-hidden="true"
  >
    <div class="comment-modal__overlay" data-comment-close></div>
    <div
      class="comment-modal__panel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="comment-modal-title"
      data-comment-panel
      tabindex="-1"
    >
      <div class="comment-modal__header">
        <div class="flex flex-col gap-1">
          <p class="font-display text-xs uppercase tracking-[0.3em] zag-muted">Komentar</p>
          <h3
            class="font-display text-lg uppercase tracking-[0.2em]"
            id="comment-modal-title"
          >
            Bagikan responmu
          </h3>
        </div>
        <button
          type="button"
          class="comment-modal__close"
          data-comment-close
          aria-label="Tutup popup komentar"
        >
          âœ•
        </button>
      </div>
      <p class="text-sm text-zag-dark/80 dark:text-zag-light/80">
        Ceritakan satu hal yang kamu rasakan setelah membaca artikel ini.
      </p>
      <p
        class="text-xs text-zag-dark/70 dark:text-zag-light/60"
        data-loading-state
      >
        Menyiapkan data interaksi...
      </p>
      <p
        class="text-sm font-mono uppercase tracking-[0.3em] text-emerald-700 dark:text-emerald-300 hidden"
        data-status-message
        aria-live="polite"
      ></p>
      <ul class="flex flex-col gap-4" data-comment-list></ul>
      <p
        class="text-sm text-zag-dark/70 dark:text-zag-light/70 italic"
        data-empty-comments
      >
        Belum ada komentar. Mulai duluan, yuk?
      </p>
      <form class="flex flex-col gap-4" data-comment-form>
        <label class="flex flex-col gap-1 text-sm">
          <span>Nama (opsional)</span>
          <input
            type="text"
            name="name"
            class="rounded-2xl border-2 border-black/40 dark:border-white/40 bg-transparent px-4 py-2 outline-none focus-visible:border-emerald-400"
            placeholder="Mis. Nadya, Teman Belajar"
            autocomplete="name"
          />
        </label>
        <label class="flex flex-col gap-1 text-sm">
          <span>Pesan</span>
          <textarea
            name="comment"
            class="rounded-2xl border-2 border-black/40 dark:border-white/40 bg-transparent px-4 py-2 outline-none focus-visible:border-emerald-400 min-h-[120px]"
            placeholder="Apa bagian favoritmu, atau apa yang ingin kamu coba setelah ini?"
            required
          ></textarea>
        </label>
        <button
          type="submit"
          class="self-start rounded-2xl border-2 border-black/70 dark:border-white/70 px-4 py-3 font-mono text-xs uppercase tracking-[0.3em] zag-transition hover:-translate-y-0.5 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-400 disabled:opacity-60"
        >
          Kirim Komentar
        </button>
      </form>
    </div>
  </div>
  <script is:inline>
    (() => {
      if (typeof window === "undefined") return;

      const script = document.currentScript;
      const root = script?.closest?.("[data-engagement]");
      if (!root) return;

      const slug = root.getAttribute("data-slug") ?? "artikel";
      const likesSeed = Number(root.getAttribute("data-likes-seed")) || 0;
      const supabaseReady = root.getAttribute("data-supabase-ready") === "true";
      const supabaseUrl = root.getAttribute("data-supabase-url")?.replace(/\/+$/, "") ?? "";
      const supabaseKey = root.getAttribute("data-supabase-key") ?? "";
      const likeButtons = Array.from(root.querySelectorAll("[data-like-button]"));
      const primaryLikeButton = likeButtons[0] ?? null;
      const likeCountEls = Array.from(root.querySelectorAll("[data-like-count]"));
      const commentList = root.querySelector("[data-comment-list]");
      const emptyState = root.querySelector("[data-empty-comments]");
      const form = root.querySelector("[data-comment-form]");
      const nameInput = form?.querySelector?.("[name='name']");
      const commentInput = form?.querySelector?.("[name='comment']");
      const submitButton = form?.querySelector?.("button[type='submit']");
      const loadingState = root.querySelector("[data-loading-state]");
      const statusMessage = root.querySelector("[data-status-message]");
      const commentModal = root.querySelector("[data-comment-modal]");
      const commentPanel = commentModal?.querySelector?.("[data-comment-panel]");
      const commentToggleButtons = Array.from(root.querySelectorAll("[data-comment-toggle]"));
      const commentCloseButtons = Array.from(root.querySelectorAll("[data-comment-close]"));
      const floatingControls = Array.from(root.querySelectorAll("[data-floating-controls]"));

      const likesKey = `ibedes:likes:${slug}`;
      const commentsKey = `ibedes:comments:${slug}`;
      const userHashKey = `ibedes:user-hash`;
      const MAX_CLAPS = 50;
      const useRemote = supabaseReady && Boolean(supabaseUrl && supabaseKey);

      const parseJSON = (value) => {
        try {
          return JSON.parse(value ?? "");
        } catch {
          return null;
        }
      };

      const normalizeLikesState = (state) => {
        if (!state || typeof state !== "object") {
          return {
            count: likesSeed,
            claps: 0,
          };
        }
        const next = {
          count: Number.isFinite(Number(state.count)) ? Number(state.count) : likesSeed,
          claps: Number.isFinite(Number(state.claps))
            ? Number(state.claps)
            : state.liked
              ? 1
              : 0,
        };
        next.claps = Math.max(0, Math.min(MAX_CLAPS, next.claps));
        return next;
      };

      let likesState = normalizeLikesState(parseJSON(window.localStorage.getItem(likesKey)));
      let lastFocusedElement = null;
      let modalHideTimeout = null;

      const setStatusMessage = (message = "", variant = "info") => {
        if (!statusMessage) return;
        if (!message) {
          statusMessage.hidden = true;
          statusMessage.textContent = "";
          statusMessage.style.color = "";
          return;
        }
        statusMessage.hidden = false;
        statusMessage.textContent = message;
        statusMessage.style.color =
          variant === "error"
            ? "rgb(220,38,38)"
            : "rgb(4,120,87)";
      };

      const setLoading = (state) => {
        if (!loadingState) return;
        loadingState.hidden = !state;
      };

      const updateLikeUI = () => {
        likeCountEls.forEach((el) => {
          el.textContent = `${likesState.count}`;
        });
        likeButtons.forEach((button) => {
          const reachedLimit = likesState.claps >= MAX_CLAPS;
          button.disabled = reachedLimit;
          button.setAttribute("aria-pressed", likesState.claps > 0 ? "true" : "false");
        });
      };

      const persistLikes = () => {
        window.localStorage.setItem(likesKey, JSON.stringify(likesState));
      };

      const getUserHash = () => {
        const existing = window.localStorage.getItem(userHashKey);
        if (existing) return existing;
        const fresh =
          window.crypto?.randomUUID?.() ??
          `${Date.now()}-${Math.random().toString(16).slice(2)}`;
        window.localStorage.setItem(userHashKey, fresh);
        return fresh;
      };

      const userHash = getUserHash();

      const emitFlyingLove = (anchorButton, count = 3) => {
        if (!anchorButton || !document?.body) return;
        const floatingRoot = anchorButton.closest("[data-floating-controls]");
        if (!floatingRoot || window.getComputedStyle(floatingRoot).display === "none") return;
        const rect = anchorButton.getBoundingClientRect();
        const originX = rect.left + rect.width / 2;
        const originY = rect.top + rect.height / 2;
        const total = Math.max(1, count);
        for (let i = 0; i < total; i += 1) {
          const heart = document.createElement("span");
          heart.className = "love-particle";
          heart.textContent = Math.random() > 0.6 ? "ðŸ’–" : "â¤ï¸";
          heart.style.setProperty("--love-left", `${originX}px`);
          heart.style.setProperty("--love-top", `${originY}px`);
          heart.style.setProperty("--love-offset-x", `${(Math.random() - 0.5) * 160}px`);
          heart.style.setProperty("--love-scale", `${0.8 + Math.random() * 0.8}`);
          heart.style.setProperty("--love-delay", `${i * 70}ms`);
          heart.style.setProperty("--love-duration", `${1.7 + Math.random() * 0.9}s`);
          heart.style.setProperty("--love-rotation", `${(Math.random() - 0.5) * 50}deg`);
          document.body.appendChild(heart);
          heart.addEventListener(
            "animationend",
            () => {
              heart.remove();
            },
            { once: true },
          );
        }
      };

      const applyClapLocally = (anchorButton) => {
        likesState = {
          ...likesState,
          count: likesState.count + 1,
          claps: Math.min(MAX_CLAPS, likesState.claps + 1),
        };
        persistLikes();
        updateLikeUI();
        emitFlyingLove(anchorButton, 4);
      };

      updateLikeUI();
      floatingControls.forEach((el) => {
        el.hidden = false;
        el.classList.add("engagement-floating-container", "engagement-floating--hidden");
      });

      const updateFloatingVisibility = () => {
        const doc = document.documentElement;
        const scrollTop = doc.scrollTop || document.body.scrollTop || 0;
        const scrollHeight = doc.scrollHeight || document.body.scrollHeight || 0;
        const clientHeight = doc.clientHeight || window.innerHeight || 1;
        const maxScroll = Math.max(1, scrollHeight - clientHeight);
        const progress = scrollHeight <= clientHeight ? 1 : scrollTop / maxScroll;
        const shouldShow = progress >= 0.3;
        floatingControls.forEach((el) => {
          el.classList.toggle("engagement-floating--visible", shouldShow);
          el.classList.toggle("engagement-floating--hidden", !shouldShow);
        });
      };

      updateFloatingVisibility();
      window.addEventListener("scroll", updateFloatingVisibility, { passive: true });

      const scrollToComments = () => {
        const target = form ?? commentList ?? root;
        target?.scrollIntoView({ behavior: "smooth", block: "start" });
        if (commentInput) {
          window.setTimeout(() => commentInput.focus(), 400);
        }
      };

      const openCommentModal = () => {
        if (!commentModal) {
          scrollToComments();
          return;
        }
        window.clearTimeout(modalHideTimeout);
        lastFocusedElement =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;
        commentModal.hidden = false;
        commentModal.setAttribute("aria-hidden", "false");
        window.requestAnimationFrame(() => {
          commentModal.classList.add("comment-modal--visible");
        });
        document.body.classList.add("comment-modal-open");
        window.setTimeout(() => {
          commentPanel?.focus();
        }, 60);
      };

      const closeCommentModal = () => {
        if (!commentModal || commentModal.hidden) return;
        commentModal.classList.remove("comment-modal--visible");
        commentModal.setAttribute("aria-hidden", "true");
        document.body.classList.remove("comment-modal-open");
        modalHideTimeout = window.setTimeout(() => {
          if (!commentModal.classList.contains("comment-modal--visible")) {
            commentModal.hidden = true;
          }
        }, 220);
        lastFocusedElement?.focus?.();
        lastFocusedElement = null;
      };

      commentToggleButtons.forEach((button) => {
        button.addEventListener("click", () => {
          openCommentModal();
        });
      });

      commentCloseButtons.forEach((button) => {
        button.addEventListener("click", () => {
          closeCommentModal();
        });
      });

      commentModal?.addEventListener("click", (event) => {
        if (event.target === commentModal) {
          closeCommentModal();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !commentModal?.hidden) {
          closeCommentModal();
        }
      });

      const renderEmptyState = () => {
        if (!emptyState) return;
        emptyState.hidden = Boolean(comments.length);
      };

      const sanitize = (value, fallback = "") => {
        if (typeof value !== "string") return fallback;
        return value.trim() || fallback;
      };

      const formatDate = (isoString) => {
        try {
          return new Intl.DateTimeFormat("id-ID", {
            dateStyle: "medium",
            timeStyle: "short",
          }).format(new Date(isoString));
        } catch {
          return isoString;
        }
      };

      const buildCommentItem = (comment) => {
        const li = document.createElement("li");
        li.dataset.commentId = comment.id;
        li.className =
          "flex flex-col gap-1 rounded-2xl border border-black/15 dark:border-white/20 bg-white/80 dark:bg-black/30 p-4";
        li.innerHTML = `
          <div class="flex items-center justify-between gap-4">
            <p class="font-semibold">${comment.name}</p>
            <span class="text-xs text-zag-dark/70 dark:text-zag-light/70">${formatDate(comment.createdAt)}</span>
          </div>
          <p class="text-sm leading-relaxed">${comment.message}</p>
        `;
        return li;
      };

      const loadComments = () => {
        const stored = parseJSON(window.localStorage.getItem(commentsKey));
        if (!Array.isArray(stored)) return [];
        return stored;
      };

      let comments = useRemote ? [] : loadComments();

      const renderComments = () => {
        if (!commentList) return;
        commentList.innerHTML = "";
        comments.forEach((comment) => {
          commentList.appendChild(buildCommentItem(comment));
        });
        renderEmptyState();
      };

      const persistComments = () => {
        if (useRemote) return;
        window.localStorage.setItem(commentsKey, JSON.stringify(comments.slice(0, 50)));
      };

      if (!useRemote) {
        renderComments();
        setLoading(false);
      }

      const supabaseHeaders = () => ({
        apikey: supabaseKey,
        Authorization: `Bearer ${supabaseKey}`,
        "Content-Type": "application/json",
      });

      const fetchLikeCount = async () => {
        if (!useRemote) return likesState.count;
        const params = new URLSearchParams({
          select: "id",
          slug: `eq.${slug}`,
        });
        const response = await fetch(
          `${supabaseUrl}/rest/v1/article_likes?${params.toString()}`,
          {
            headers: {
              ...supabaseHeaders(),
              Prefer: "count=exact",
            },
          },
        );
        if (!response.ok) {
          throw new Error("Gagal memuat data suka");
        }
        const range = response.headers.get("content-range");
        if (range && /\/(\d+)$/.test(range)) {
          const [, total] = range.match(/\/(\d+)$/) ?? [];
          return Number(total) || likesState.count;
        }
        const data = await response.json();
        return Array.isArray(data) ? data.length : likesState.count;
      };

      const fetchCommentsRemote = async () => {
        if (!useRemote) return comments;
        const params = new URLSearchParams({
          select: "id,name,message,created_at",
          slug: `eq.${slug}`,
          order: "created_at.desc",
          limit: "50",
        });
        const response = await fetch(
          `${supabaseUrl}/rest/v1/article_comments?${params.toString()}`,
          {
            headers: supabaseHeaders(),
          },
        );
        if (!response.ok) {
          throw new Error("Gagal memuat komentar");
        }
        const data = await response.json();
        if (!Array.isArray(data)) return [];
        return data.map((comment) => ({
          id: comment.id ?? crypto.randomUUID?.() ?? String(Date.now()),
          name: sanitize(comment.name, "Anonim"),
          message: sanitize(comment.message),
          createdAt: comment.created_at ?? new Date().toISOString(),
        }));
      };

      const bootstrap = async () => {
        if (!useRemote) return;
        try {
          setLoading(true);
          const [remoteLikes, remoteComments] = await Promise.all([
            fetchLikeCount(),
            fetchCommentsRemote(),
          ]);
          likesState.count = Number.isFinite(remoteLikes)
            ? remoteLikes
            : likesState.count;
          comments = remoteComments;
          persistLikes();
          renderComments();
          updateLikeUI();
          setStatusMessage("Data tersinkron dengan Supabase.");
        } catch (error) {
          console.error(error);
          setStatusMessage("Gagal memuat data Supabase. Menampilkan cadangan lokal.", "error");
          comments = loadComments();
          renderComments();
        } finally {
          setLoading(false);
        }
      };

      bootstrap();

      form?.addEventListener("submit", (event) => {
        event.preventDefault();
        const message = commentInput?.value?.trim();
        if (!message) {
          commentInput?.focus();
          return;
        }
        const name = nameInput?.value?.trim() || "Anonim";

        const submitLocalComment = (createdAt = new Date().toISOString()) => {
          const newComment = {
            id:
              typeof crypto !== "undefined" && crypto.randomUUID
                ? crypto.randomUUID()
                : `${Date.now()}-${Math.random().toString(16).slice(2)}`,
            name,
            message,
            createdAt,
          };
          comments = [newComment, ...comments].slice(0, 50);
          persistComments();
          renderComments();
          form.reset();
        };

        const sendToSupabase = async () => {
          if (!useRemote) {
            submitLocalComment();
            setStatusMessage("Komentar tersimpan di perangkatmu.");
            return;
          }
          submitButton?.setAttribute("disabled", "true");
          setStatusMessage("Mengirim komentar...");
          try {
            const response = await fetch(`${supabaseUrl}/rest/v1/article_comments`, {
              method: "POST",
              headers: {
                ...supabaseHeaders(),
                Prefer: "return=representation",
              },
              body: JSON.stringify({
                slug,
                name,
                message,
                status: "published",
              }),
            });
            if (!response.ok) {
              throw new Error("Komentar gagal dikirim");
            }
            const data = await response.json();
            const saved = Array.isArray(data) ? data[0] : null;
            submitLocalComment(saved?.created_at ?? new Date().toISOString());
            setStatusMessage("Komentar terkirim!");
          } catch (error) {
            console.error(error);
            submitLocalComment();
            setStatusMessage("Gagal ke Supabase, komentar disimpan lokal.", "error");
          } finally {
            submitButton?.removeAttribute("disabled");
          }
        };

        sendToSupabase();
      });

      const handleSupabaseLike = async (anchorButton = primaryLikeButton) => {
        if (likesState.claps >= MAX_CLAPS) {
          setStatusMessage("Kamu sudah memberi 50 tepuk untuk artikel ini.", "error");
          return;
        }

        if (!useRemote) {
          applyClapLocally(anchorButton);
          setStatusMessage(`Tepuk tersimpan di perangkatmu (${likesState.claps}/${MAX_CLAPS}).`);
          return;
        }
        anchorButton?.setAttribute("data-loading", "true");
        setStatusMessage("Mengirim suka...");
        try {
          const response = await fetch(`${supabaseUrl}/rest/v1/article_likes`, {
            method: "POST",
            headers: {
              ...supabaseHeaders(),
              Prefer: "return=minimal",
            },
            body: JSON.stringify({
              slug,
              user_hash: userHash,
            }),
          });
          if (!response.ok) {
            throw new Error("Gagal menambahkan suka");
          }
          applyClapLocally(anchorButton);
          setStatusMessage(
            likesState.claps >= MAX_CLAPS
              ? "Terima kasih! Batas 50 tepuk sudah kamu capai."
              : "Terima kasih sudah apresiasi!",
          );
        } catch (error) {
          console.error(error);
          setStatusMessage("Suka gagal dikirim. Coba lagi.", "error");
        } finally {
          anchorButton?.removeAttribute("data-loading");
        }
      };

      likeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          if (likesState.claps >= MAX_CLAPS) {
            setStatusMessage("Kamu sudah memberi 50 tepuk untuk artikel ini.", "error");
            return;
          }
          handleSupabaseLike(button);
        });
      });

      if (useRemote) {
        window.addEventListener("online", () => {
          bootstrap();
        });
      }
    })();
  </script>
</section>

<style>
  .engagement-icon {
    font-size: 1.2rem;
    line-height: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .engagement-icon--love {
    color: #f43f5e;
  }

  .engagement-icon--comment {
    color: inherit;
  }

  :global(.dark) [data-engagement] .engagement-icon--love {
    color: #fda4af;
  }

  .comment-modal {
    position: fixed;
    inset: 0;
    padding: 1.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 220ms ease;
    z-index: 60;
  }

  .comment-modal[hidden] {
    display: none;
  }

  .comment-modal--visible {
    opacity: 1;
    pointer-events: auto;
  }

  .comment-modal__overlay {
    position: absolute;
    inset: 0;
    background: rgba(15, 23, 42, 0.45);
    backdrop-filter: blur(3px);
  }

  .comment-modal__panel {
    position: relative;
    width: min(600px, 100%);
    max-height: min(90vh, 720px);
    overflow-y: auto;
    border-radius: 1.5rem;
    border: 2px solid rgba(0, 0, 0, 0.7);
    background: rgba(255, 255, 255, 0.98);
    padding: 2rem;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.25);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    transform: translateY(12px);
    transition: transform 220ms ease;
  }

  .comment-modal--visible .comment-modal__panel {
    transform: translateY(0);
  }

  .comment-modal__header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 1rem;
  }

  .comment-modal__close {
    border-radius: 999px;
    border: 2px solid transparent;
    background: rgba(0, 0, 0, 0.05);
    width: 2.25rem;
    height: 2.25rem;
    font-size: 1rem;
    transition: background 150ms ease;
  }

  .comment-modal__close:hover {
    background: rgba(16, 185, 129, 0.15);
  }

  :global(.dark) [data-engagement] .comment-modal__panel {
    background: rgba(24, 24, 27, 0.96);
    border-color: rgba(255, 255, 255, 0.25);
    color: #f8fafc;
    box-shadow: 0 30px 80px rgba(3, 7, 18, 0.9);
  }

  :global(.dark) [data-engagement] .comment-modal__close {
    background: rgba(255, 255, 255, 0.08);
  }

  :global(body.comment-modal-open) {
    overflow: hidden;
  }

  :global(.love-particle) {
    position: fixed;
    top: var(--love-top, 0px);
    left: var(--love-left, 0px);
    font-size: 1.4rem;
    animation: loveParticleFloat var(--love-duration, 1.8s) ease-out forwards;
    animation-delay: var(--love-delay, 0ms);
    transform: translate3d(0, 0, 0);
    pointer-events: none;
    filter: drop-shadow(0 12px 24px rgba(244, 63, 94, 0.45));
    z-index: 70;
  }

  @keyframes loveParticleFloat {
    0% {
      opacity: 0;
      transform: translate3d(0, 12px, 0)
        scale(calc(var(--love-scale, 1) * 0.8))
        rotate(var(--love-rotation, 0deg));
    }
    20% {
      opacity: 1;
      transform: translate3d(var(--love-offset-x, 0px), -10px, 0)
        scale(var(--love-scale, 1))
        rotate(var(--love-rotation, 0deg));
    }
    100% {
      opacity: 0;
      transform: translate3d(calc(var(--love-offset-x, 0px) * 1.3), -260px, 0)
        scale(calc(var(--love-scale, 1) + 0.45))
        rotate(var(--love-rotation, 0deg));
    }
  }

  @media (max-width: 640px) {
    .comment-modal {
      padding: 1rem;
    }
    .comment-modal__panel {
      padding: 1.25rem;
      border-radius: 1.25rem;
    }
  }

  .engagement-floating-container {
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 220ms ease, transform 260ms ease;
    pointer-events: none;
  }

  .engagement-floating--visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .engagement-floating--hidden {
    opacity: 0;
    transform: translateY(12px);
    pointer-events: none;
  }

  .engagement-fab {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    display: none;
    flex-direction: column;
    gap: 0.75rem;
    z-index: 40;
  }

  .engagement-fab__button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 3.25rem;
    height: 3.25rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.6);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
    color: #111;
    font-size: 1.3rem;
    transition: transform 150ms ease, border-color 150ms ease;
  }

  .engagement-fab__button:hover {
    transform: translateY(-2px);
    border-color: rgba(16, 185, 129, 0.9);
  }

  .engagement-fab__count {
    font-size: 0.85rem;
    font-weight: 600;
    margin-left: 0.35rem;
  }

  .engagement-mobile-bar {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 1rem;
    width: min(92vw, 360px);
    display: none;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
    z-index: 40;
    backdrop-filter: blur(8px);
  }

  .engagement-mobile-bar__action {
    flex: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    border-radius: 999px;
    border: 2px solid rgba(0, 0, 0, 0.4);
    background: transparent;
    font-size: 0.95rem;
    padding: 0.4rem 0.6rem;
  }

  .engagement-mobile-bar__action:first-of-type {
    background: rgba(16, 185, 129, 0.12);
    border-color: rgba(16, 185, 129, 0.5);
  }

  @media (max-width: 1023px) {
    .engagement-mobile-bar {
      display: flex;
    }
  }

  @media (min-width: 1024px) {
    .engagement-fab {
      display: flex;
    }
    .engagement-mobile-bar {
      display: none;
    }
  }

  :global(.dark) [data-engagement] :where(.engagement-fab__button, .engagement-mobile-bar, .engagement-mobile-bar__action) {
    background: rgba(24, 24, 27, 0.9);
    border-color: rgba(255, 255, 255, 0.2);
    color: #f8fafc;
  }

  :global(.dark) [data-engagement] :where(.engagement-fab__button-like, .engagement-mobile-bar__action:first-of-type) {
    background: rgba(16, 185, 129, 0.14);
    border-color: rgba(16, 185, 129, 0.5);
    color: #ecfdf5;
  }

</style>
