---
import Section from "../components/common/Section.astro";
import type { ArticleFrontmatter } from "../lib/types";
import {
  getShortDescription,
  processArticleDate,
  generateSourceUrl,
} from "../lib/utils";
import { GLOBAL } from "../lib/variables";
import type { MarkdownLayoutProps } from "astro";
import Prose from "../components/Prose.astro";
import Layout from "./Layout.astro";
import SubscribeCard from "../components/SubscribeCard.astro";
import ShareActions from "../components/ShareActions.astro";
import ArticleEngagement from "../components/ArticleEngagement.astro";
import RelatedArticles from "../components/RelatedArticles.astro";
import { getArticles } from "../lib/list";
import Breadcrumbs from "../components/common/Breadcrumbs.astro";

type Props = MarkdownLayoutProps<ArticleFrontmatter>;

const { frontmatter } = Astro.props;
const shortDescription = getShortDescription(frontmatter.description);
const articleDate = processArticleDate(frontmatter.timestamp);
const sourceUrl = generateSourceUrl(frontmatter.filename, "blog");
const currentArticlePath = `/blog/${frontmatter.filename}`;
const tagSet = new Set(Array.isArray(frontmatter.tags) ? frontmatter.tags : []);
const articles = await getArticles();
const breadcrumbs = [
  { label: "Home", url: "/" },
  { label: GLOBAL.articlesName, url: "/blog" },
  { label: frontmatter.title },
];

const scoredArticles = articles
  .filter((article) => article.filename !== currentArticlePath)
  .map((article) => {
    const overlap = article.tags
      ? article.tags.reduce(
          (count, tag) => (tagSet.has(tag) ? count + 1 : count),
          0,
        )
      : 0;
    return { article, overlap };
  })
  .sort((a, b) => {
    if (tagSet.size && a.overlap !== b.overlap) {
      return b.overlap - a.overlap;
    }
    const dateA = new Date(a.article.timestamp).getTime();
    const dateB = new Date(b.article.timestamp).getTime();
    return dateB - dateA;
  });

const prioritized = tagSet.size
  ? scoredArticles.filter(({ overlap }) => overlap > 0)
  : scoredArticles;
const fallback =
  tagSet.size && prioritized.length < 3
    ? scoredArticles.filter(({ overlap }) => overlap === 0)
    : [];
const relatedArticles = [...prioritized.slice(0, 3), ...fallback].slice(0, 3).map(({ article }) => article);
---

<Layout>
  <Fragment slot="head">
    <title>{frontmatter.title} • {GLOBAL.username}</title>
    <meta name="description" content={frontmatter.description} />
    <meta property="og:title" content={`${frontmatter.title} • ${GLOBAL.username}`} />
    <meta property="og:description" content={shortDescription} />
    <meta property="og:image" content={`${GLOBAL.rootUrl}/${GLOBAL.profileImage}`} />
    <meta property="og:url" content={frontmatter.url} />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={`${frontmatter.title} • ${GLOBAL.username}`} />
    <meta name="twitter:description" content={shortDescription} />
    <meta name="twitter:image" content={`${GLOBAL.rootUrl}/${GLOBAL.profileImage}`} />
    <meta http-equiv="content-language" content="id" />
    <meta name="language" content="indonesia" />
    <link rel="canonical" href={sourceUrl} />
  </Fragment>
  <div
    class="reading-progress"
    data-reading-progress
    role="progressbar"
    aria-valuemin="0"
    aria-valuemax="100"
    aria-valuenow="0"
    aria-label="Progress membaca artikel"
  >
    <span></span>
  </div>
  <Section class="pt-8">
  <div class="max-w-prose mx-auto w-full">
    <Breadcrumbs items={breadcrumbs} />
    <div class="flex flex-col gap-4 mt-8 mb-16 w-full">
      <h1
        class="text-3xl sm:text-4xl leading-tight font-display break-words"
      >
        {frontmatter.title}
      </h1>

      <div class="flex justify-between items-center text-sm w-full">
        <span class="whitespace-nowrap">{articleDate}</span>
        <span class="whitespace-nowrap">{frontmatter.time} min</span>
      </div>
    </div>

   <div data-article-body>
    <Prose>
      <slot />
    </Prose>
  </div>

    <div class="my-12">
      <ShareActions title={frontmatter.title} url={frontmatter.url ?? sourceUrl} />
    </div>

    <div class="my-12">
      <ArticleEngagement slug={frontmatter.filename} title={frontmatter.title} />
    </div>

    {
      relatedArticles.length > 0 && (
        <div class="my-12">
          <RelatedArticles articles={relatedArticles} />
        </div>
      )
    }

   

 


  </div>
</Section>

</Layout>

<script is:inline>
  (() => {
    if (typeof window === "undefined") return;
    const progressBarContainer = document.querySelector("[data-reading-progress]");
    const progressBar = progressBarContainer?.querySelector("span");
    const articleBody = document.querySelector("[data-article-body]");

    const clamp = (value, min = 0, max = 1) => Math.min(Math.max(value, min), max);

    const updateProgress = () => {
      if (!progressBar || !articleBody) return;
      const articleRect = articleBody.getBoundingClientRect();
      const articleTop = window.scrollY + articleRect.top;
      const articleHeight = articleBody.scrollHeight;
      const viewportHeight = window.innerHeight;
      const maxScrollable = Math.max(articleHeight - viewportHeight, 0.00001);
      const progress = clamp((window.scrollY - articleTop) / maxScrollable);
      progressBar.style.transform = `scaleX(${progress})`;
      progressBar.setAttribute("aria-valuenow", (progress * 100).toFixed(0));
    };

    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          updateProgress();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener("scroll", handleScroll, { passive: true });
    window.addEventListener("resize", updateProgress);
    updateProgress();

    if (!articleBody) return;
    const markerPattern = /^\s*\[!highlight\]\s*/i;
    const blockquotes = Array.from(articleBody.querySelectorAll("blockquote"));

    blockquotes.forEach((blockquote) => {
      const firstParagraph = blockquote.querySelector("p");
      if (firstParagraph) {
        const paragraphHtml = firstParagraph.innerHTML;
        if (markerPattern.test(firstParagraph.textContent ?? "")) {
          firstParagraph.innerHTML = paragraphHtml.replace(markerPattern, "").trim();
          blockquote.classList.add("highlight-block");
        }
      }

      const button = document.createElement("button");
      button.type = "button";
      button.className = "quote-copy-button";
      button.setAttribute("aria-label", "Salin kutipan");
      button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M9 2H5a2 2 0 0 0-2 2v14h2V4h4zm10 4h-8a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 14h-8V8h8z" />
        </svg>
        <span>Salin</span>
      `;
      const setLabel = (text) => {
        const label = button.querySelector("span");
        if (label) {
          label.textContent = text;
        }
      };
      const handleCopy = async () => {
        const clone = blockquote.cloneNode(true);
        clone.querySelector(".quote-copy-button")?.remove();
        const text = clone.textContent?.trim() ?? "";
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const shadow = document.createElement("textarea");
            shadow.value = text;
            shadow.setAttribute("readonly", "");
            shadow.style.position = "absolute";
            shadow.style.left = "-9999px";
            document.body.appendChild(shadow);
            shadow.select();
            document.execCommand("copy");
            document.body.removeChild(shadow);
          }
          button.dataset.state = "copied";
          setLabel("Disalin!");
        } catch (error) {
          button.dataset.state = "error";
          setLabel("Gagal");
        } finally {
          setTimeout(() => {
            button.dataset.state = "idle";
            setLabel("Salin");
          }, 1800);
        }
      };
      button.addEventListener("click", handleCopy);
      blockquote.appendChild(button);
    });
  })();
</script>
